# 결제 라우팅 게이트웨이 (토이 프로젝트)

여러 PG(Payment Gateway)사를 연동하고, 비즈니스 로직(비용, 장애, 기능)에 따라 결제 요청을 동적으로 라우팅하는 백엔드 서비스입니다.

---

## 기술 스택 (Tech Stack)

- **Language:** Kotlin
- **Framework:** Spring Boot, Spring Web, Spring Data JPA
- **Database:** H2 (In-Memory)
- **Libraries:** Spring Cloud Circuit Breaker

---

## 핵심 요구사항

### 1. 기본 기능

- **결제 서비스 제공:** 우리 서비스의 사용자가 결제를 할 수 있도록 API를 제공합니다.
- **결제 수단:** 신용카드, 계좌이체, 네이버페이 3가지 결제 수단을 지원합니다.

### 2. 핵심: 결제 라우팅 (Routing)

결제 요청이 들어왔을 때, 비즈니스 규칙에 따라 최적의 PG사로 요청을 중개합니다.

#### A. 결제 수수료 절감 (비용 기반)

- 각 PG사별 결제 수단 수수료가 가장 저렴한 곳을 1순위로 선택합니다.
- **PG사별 수수료 테이블**

  | PG사 | 신용카드 | 계좌이체 | 네이버페이 |
  | :--- | :---: | :---: | :---: |
  | **A사** | 5% | 10% | 15% |
  | **B사** | 3% | 12% | 15% |
  | **C사** | 2% | 7% | (미지원) |

#### B. 다양한 결제 수단 확보 (기능 기반)

- 라우팅 시, 해당 PG사가 요청된 결제 수단을 지원하는지 확인합니다.
- **PG사별 지원 수단**
  - **A, B사:** 신용카드, 계좌이체, 네이버페이 모두 제공
  - **C사:** 신용카드, 계좌이체만 제공 (네이버페이 미지원)

#### C. 장애 대비 (안정성 기반)

- **전략 (Strategy)**
    - **Failover:** 1순위 PG사(e.g., A사)에서 장애 발생 시, 차순위 PG사(e.g., B사)로 결제 요청을 자동으로 재시도합니다.
    - **All Fail:** 시도한 모든 PG사에서 장애가 발생하면, 장애 로그(Log)를 DB에 기록하고 주문 상태를 '결제 실패'로 확정한 뒤, 사용자에게 "결제를 처리할 수 없습니다. 잠시 후 다시 시도해주세요."라고 응답합니다.
- **장애 판단 기준 (Failure Criteria)**
    - **Timeout:** 결제 요청을 보냈는데, **10초** 동안 응답이 없는 경우.
    - **Error Code (4xx vs 5xx):**
        - **400번대:** 클라이언트(우리 서버)의 요청 오류 (e.g., 필수 파라미터 누락). PG사 장애가 아니므로 재시도(Failover)하지 않고 즉시 '결제 실패'로 처리합니다.
        - **500번대:** PG사 서버의 장애. 장애로 간주하고 다음 순위 PG사로 재시도합니다.
    - **서킷 브레이커 (Circuit Breaker):**
        - 최근 1분간 특정 PG사의 결제 실패율(5xx, Timeout)이 30%를 초과하면, 해당 PG사를 '장애 상태'로 간주하고 10분간 라우팅에서 제외합니다.

#### D. 라우팅 정책 (기타)

- **우선순위 동일 시 (Tie-Breaking):**
    - 두 PG사의 최종 우선순위가 같다면(e.g., 네이버페이 수수료가 A, B사 15%로 동일), **라운드 로빈(Round Robin)** 방식으로 트래픽을 분산합니다.

### 3. 결제 결과 처리 (Webhook)

- PG사 결제창에서 사용자가 결제를 완료하면, PG사 서버가 우리 서버의 특정 API(Webhook)를 호출하여 결제 결과를 비동기적으로 통보합니다.
- 우리 서버는 이 Webhook 요청을 수신하여, 해당 주문의 상태를 '결제 완료(PAID)' 또는 '결제 실패(FAILED)'로 DB에 최종 확정합니다.

### 4. 확장성 (Architecture)

- 새로운 PG사(e.g., D사)가 추가되더라도, 기존 라우팅 로직의 큰 변경 없이 손쉽게 연동할 수 있는 구조로 설계합니다. (e.g., Adapter Pattern)

---

## + a (추가 고려 사항)

시간이 허용된다면 다음 주제에 대해 고민하고 구현해봅니다.

1.  **정산 문제:** PG사별로 정산 대금이 서로 다른 날짜에, 다른 포맷으로 들어옵니다. 우리 서비스의 DB 데이터와 PG사의 정산 데이터를 어떻게 비교하고 검증(대사)할 수 있을까요?
2.  **Webhook 안정성:** PG사가 Webhook을 보냈는데, **우리 서버가 일시적 장애**여서 수신에 실패(e.g., 500 에러 응답)하면 어떻게 될까요? (Hint: 멱등성, Idempotency)