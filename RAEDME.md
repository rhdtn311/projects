# 결제 라우팅 게이트웨이 (토이 프로젝트)

여러 PG(Payment Gateway)사를 연동하고, 비즈니스 로직(비용, 장애, 기능)에 따라 결제 요청을 동적으로 라우팅하는 백엔드 서비스입니다.

---

## 기술 스택 (Tech Stack)

- **Language:** Kotlin
- **Framework:** Spring Boot, Spring Web, Spring Data JPA
- **Database:** H2 (In-Memory)
- **Libraries:** Spring Cloud Circuit Breaker

---

## 핵심 요구사항

### 1. 기본 기능

- **결제 서비스 제공:** 우리 서비스의 사용자가 결제를 할 수 있도록 API를 제공합니다.
- **결제 수단:** 신용카드, 계좌이체, 네이버페이 3가지 결제 수단을 지원합니다.

### 2. 핵심: 결제 라우팅 (Routing)

결제 요청이 들어왔을 때, 비즈니스 규칙에 따라 최적의 PG사로 요청을 중개합니다.

#### A. 결제 수수료 절감 (비용 기반)

- 각 PG사별 결제 수단 수수료가 가장 저렴한 곳을 1순위로 선택합니다.
- **PG사별 수수료 테이블**

  | PG사 | 신용카드 | 계좌이체 | 네이버페이 |
  | :--- | :---: | :---: | :---: |
  | **A사** | 5% | 10% | 15% |
  | **B사** | 3% | 12% | 15% |
  | **C사** | 2% | 7% | (미지원) |

#### B. 다양한 결제 수단 확보 (기능 기반)

- 라우팅 시, 해당 PG사가 요청된 결제 수단을 지원하는지 확인합니다.
- **PG사별 지원 수단**
  - **A, B사:** 신용카드, 계좌이체, 네이버페이 모두 제공
  - **C사:** 신용카드, 계좌이체만 제공 (네이버페이 미지원)

#### C. 장애 대비 (안정성 기반)

- **전략 (Strategy)**
    - **Failover:** 1순위 PG사(e.g., A사)에서 장애 발생 시, 차순위 PG사(e.g., B사)로 결제 요청을 자동으로 재시도합니다.
    - **All Fail:** 시도한 모든 PG사에서 장애가 발생하면, 장애 로그(Log)를 DB에 기록하고 주문 상태를 '결제 실패'로 확정한 뒤, 사용자에게 "결제를 처리할 수 없습니다. 잠시 후 다시 시도해주세요."라고 응답합니다.
- **장애 판단 기준 (Failure Criteria)**
    - **Timeout:** 결제 요청을 보냈는데, **10초** 동안 응답이 없는 경우.
    - **Error Code (4xx vs 5xx):**
        - **400번대:** 클라이언트(우리 서버)의 요청 오류 (e.g., 필수 파라미터 누락). PG사 장애가 아니므로 재시도(Failover)하지 않고 즉시 '결제 실패'로 처리합니다.
        - **500번대:** PG사 서버의 장애. 장애로 간주하고 다음 순위 PG사로 재시도합니다.
    - **서킷 브레이커 (Circuit Breaker):**
        - 최근 1분간 특정 PG사의 결제 실패율(5xx, Timeout)이 30%를 초과하면, 해당 PG사를 '장애 상태'로 간주하고 10분간 라우팅에서 제외합니다.

#### D. 라우팅 정책 (기타)

- **우선순위 동일 시 (Tie-Breaking):**
    - 두 PG사의 최종 우선순위가 같다면(e.g., 네이버페이 수수료가 A, B사 15%로 동일), **랜덤** 방식으로 트래픽을 분산합니다.

### 3. 결제 결과 처리 (Webhook)

- PG사 결제창에서 사용자가 결제를 완료하면, PG사 서버가 우리 서버의 특정 API(Webhook)를 호출하여 결제 결과를 비동기적으로 통보합니다.
- 우리 서버는 이 Webhook 요청을 수신하여, 해당 주문의 상태를 '결제 완료(PAID)' 또는 '결제 실패(FAILED)'로 DB에 최종 확정합니다.

### 4. 확장성 (Architecture)

- 새로운 PG사(e.g., D사)가 추가되더라도, 기존 라우팅 로직의 큰 변경 없이 손쉽게 연동할 수 있는 구조로 설계합니다. (e.g., Adapter Pattern)

---

## + a (추가 고려 사항)

시간이 허용된다면 다음 주제에 대해 고민하고 구현해봅니다.

1.  **정산 문제:** PG사별로 정산 대금이 서로 다른 날짜에, 다른 포맷으로 들어옵니다. 우리 서비스의 DB 데이터와 PG사의 정산 데이터를 어떻게 비교하고 검증(대사)할 수 있을까요?
2.  **Webhook 안정성:** PG사가 Webhook을 보냈는데, **우리 서버가 일시적 장애**여서 수신에 실패(e.g., 500 에러 응답)하면 어떻게 될까요? (Hint: 멱등성, Idempotency)

---
## 프로젝트 세팅법

1. 사전 준비물
   - JDK 21
   - Git

2. 소스 받기
   - Git 사용 시: 저장소를 클론하거나 로컬에 ZIP으로 내려받아 압축 해제
   - 프로젝트 루트로 이동: `pg-routing`

3. 빌드
   - 명령어: `./gradlew clean build` (Windows: `gradlew.bat clean build`)
   - 성공 시 `build/libs/pg-routing-0.0.1-SNAPSHOT.jar` 생성

4. 로컬 설정 확인/수정
   - `src/main/resources/application.yaml`
     - 기본 포트: 8080 (변경하려면 `server.port` 설정 추가)
     - H2 인메모리 DB 사용
   - `src/main/resources/pg-policy.yaml`
     - PG사별 수수료 및 지원 수단 정책을 정의하는 파일
     - 예시:
       ```yaml
       gateways:
         - name: INICIS  # PG사 이름
           fees:  # PG사별 결제수단 수수료 비율
             CARD: 0.03  # 카드결제
             TRANSFER: 0.12  # 계좌이체
             NAVERPAY: 0.15  # 네이버페이
           supports: [CARD, TRANSFER, NAVERPAY]  # 지원하는 결제수단
         - name: TOSS
           fees:
             CARD: 0.02
             TRANSFER: 0.07
           supports: [CARD, TRANSFER]
       ```
     - 필요 시 위 설정값을 수정하여 비율/지원 수단을 환경에 맞게 수정 가능

5. 애플리케이션 실행
   - 개발 모드: `./gradlew bootRun`
   - JAR로 실행: `java -jar build/libs/pg-routing-0.0.1-SNAPSHOT.jar`

## 6. 기본 동작 확인

- **테스트 페이지 접속**  
  브라우저에서 `http://localhost:8080/test.html` 을 엽니다.

- **사전 작업 (필수)**  
  결제 요청 테스트를 위해, 먼저 각 PG사의 장애 상태를 설정해야 합니다.  
  테스트 페이지의 **`2. Failover & 서킷 테스트`** 영역에서 아래 버튼을 사용해 상태를 변경합니다.

    - **PG사 정상**: 해당 PG사 요청이 정상 응답됩니다.
    - **PG사 5xx 강제**: 해당 PG사 요청 시 5xx 서버 오류를 강제로 발생시킵니다.
    - **PG사 Timeout 강제**: 해당 PG사 요청 시 Timeout 오류를 강제로 발생시킵니다.

- **기본 결제 요청 테스트**
    1. 금액과 상품명을 입력합니다.
    2. 원하는 결제수단 버튼을 클릭합니다.
    3. 결과는 **`3. 서버 응답`** 영역에서 확인할 수 있으며, 어떤 PG사로 라우팅되었는지 확인 가능합니다.
